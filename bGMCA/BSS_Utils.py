import numpy as np    from scipy import specialimport scipy.linalg as lng import copy as cpfrom scipy import signal as sngimport sample_nmr_spectra as snp##### Generating functionsdef generate_2D_generalized_gaussian(rows, columns, alpha=2):        m = rows    n = columns    r = 0.5 * np.random.random(m * n) + 0.5  # distribution is symmetric    beta = np.sqrt(special.gamma(3.0 / alpha) /                   special.gamma(1.0 / alpha))  # enough to consider r > 0.5    y = r / beta    ymin = 1e-20 * np.ones(m * n)    ymax = 1000 * np.ones(m * n)    # for simplicity, generated r.v. are bounded by 1000.    for iter in range(0, 33):        cdf = 0.5 + 0.5 * special.gammainc(1.0 / alpha, (beta * y) ** alpha)        indplus = np.nonzero(cdf > r)        if len(indplus) > 0:            ymax[indplus] = y[indplus]        indminus = np.nonzero(cdf < r)        if len(indminus) > 0:            ymin[indminus] = y[indminus]        y = 0.5 * (ymax + ymin)    ind = np.nonzero(np.random.random(m * n) > 0.5)    if len(ind) > 0:        y[ind] = -y[ind]    x = y.reshape([n, m]).T.copy()    return x##### Generating functionsdef MixtMod(n=2,t=1024,sigma1=1,p1=0.2,ptot=0.1):    S = np.zeros((n,t))    Sc_part = np.zeros((n,t))    num_cor = np.floor(p1*ptot*t)    ind_cor = randperm(t)    ind_cor = ind_cor[0:num_cor]    ind = np.ones((1,t))    ind[0,ind_cor] = 0       ind_nocor = np.where(ind[0,:] == 1)[0]         rest = t - num_cor        for r in range(0,n):        p_active = np.floor(t*ptot*(1.-p1))        temp = np.random.randn(1,rest)        ind = randperm(rest)        temp[0,ind[p_active+1:rest]] = 0        cor_val = sigma1*np.random.randn(1,num_cor)        S[r,ind_cor] = cor_val        S[r,ind_nocor] = temp        Sc_part[r,ind_cor] = cor_val            return S,Sc_part,ind_cor,ind_nocor    # Get a mixing matrix with a given condition number    def Get_MixmatCond(n,m,cd):    nmax = 25    A0 = np.random.randn(m,n)    if (cd > 1):        v = np.linspace(0,n,n)        v = (1 - 1./cd)*v/n + 1./cd    if (cd == 1):        v = np.ones((n,1))            Sq = np.zeros((m,n))    for r in range(0,np.min((m,n))):        Sq[r,r] = v[r]    for r in range(0,nmax):        ue,se,ve = np.linalg.svd(A0)        A0 = np.dot(np.dot(ue,Sq),ve.T)        for t in range(0,n):            A0[:,t] = A0[:,t]/np.sqrt(np.sum(np.power(A0[:,t],2)))    return A0            # Generating function. Creates data matrix with sources following a Bernouilli Gaussian distribution.def Make_Experiment_Exact(n_s=2,n_obs=2,t_samp=1024,noise_level=40,dynamic=10,ptot=0.1,cd=1):    S = np.zeros((n_s,t_samp))    p_active = np.floor(t_samp*ptot)        for r in range(0,n_s):                ind = randperm(t_samp)        S[r,ind[0:p_active.astype(int)]] = np.random.randn(p_active.astype(int))    val = np.power(10,(-np.linspace(1,n_s-1,n_s)/(n_s-1)*dynamic))        A0 = Get_MixmatCond(n_s,n_obs,cd)        S0= np.dot(np.diag(1./np.sqrt(np.sum(S*S,axis=1))),S)    S0 = np.dot(np.diag(val),S0)    X0 = np.dot(A0,S0)    N = np.random.randn(n_obs,t_samp)    sigma_noise = np.power(10,(-noise_level/20))*np.linalg.norm(X0,ord='fro')/np.linalg.norm(N,ord='fro')    print(sigma_noise)    N = sigma_noise*N        X = X0 + N    return X,X0,A0,S0,N        # Generating function. Generates a data matrix with sources following a generalized gaussian distributiondef Make_Experiment_GeneralizedGaussian(n_s=2,n_obs=2,t_samp=1024,noise_level=40,dynamic=10,ptot=0.1,cd=1,alpha=2):    S = np.zeros((n_s,t_samp))    p_active = np.floor(t_samp*ptot)        for r in range(0,n_s):                ind = randperm(t_samp)        S[r,ind[0:p_active]] = generate_2D_generalized_gaussian(1, p_active.astype(int), alpha)    val = np.power(10,(-np.linspace(1,n_s-1,n_s)/(n_s-1)*dynamic))    A0 = Get_MixmatCond(n_s,n_obs,cd)        S0= np.dot(np.diag(1./np.sqrt(np.sum(S*S,axis=1))),S)    S0 = np.dot(np.diag(val),S0)    X0 = np.dot(A0,S0)    N = np.random.randn(n_obs,t_samp)    sigma_noise = np.power(10,(-noise_level/20))*np.linalg.norm(X0,ord='fro')/np.linalg.norm(N,ord='fro')    N = sigma_noise*N    X = X0 + N    return X,X0,A0,S0,N# Creates a random permutationdef randperm(n=1):    X = np.random.randn(n)    I = X.argsort()        return I# Correction of the permutation inderterminacy   def CorrectPerm(cA0,S0,cA,S,optEchAS=0):    A0 = cp.copy(cA0)    A = cp.copy(cA)        nX = np.shape(A0)        for r in range(0,nX[1]):        S[r,:] = S[r,:]*(1e-24+lng.norm(A[:,r]))        A[:,r] = A[:,r]/(1e-24+lng.norm(A[:,r]))        S0[r,:] = S0[r,:]*(1e-24+lng.norm(A0[:,r]))        A0[:,r] = A0[:,r]/(1e-24+lng.norm(A0[:,r]))            try:        Diff = abs(np.dot(lng.inv(np.dot(A0.T,A0)),np.dot(A0.T,A)))    except np.linalg.LinAlgError:        Diff = abs(np.dot(np.linalg.pinv(A0),A))            print('WARNING, PSEUDO INVERSE TO CORRECT PERMUTATIONS')                                Sq = np.ones(np.shape(S))    ind = np.linspace(0,nX[1]-1,nX[1])        for ns in range(0,nX[1]):        indix = np.where(Diff[ns,:] == max(Diff[ns,:]))[0]        ind[ns] = indix[0]        Aq = A[:,ind.astype(int)]    Sq = S[ind.astype(int),:]    for ns in range(0,nX[1]):        p = np.sum(Sq[ns,:]*S0[ns,:])        if p < 0:            Sq[ns,:] = -Sq[ns,:]            Aq[:,ns] = -Aq[:,ns]           if optEchAS==1:        return Aq,Sq,A0,S0    else:        return Aq,Sq        # CODE TO COMPUTE THE MIXING MATRIX CRITERION (AND SOLVES THE PERMUTATION INDETERMINACY)      def EvalCriterion(A0,S0,A,S,optMedian=1):            gA,gS = CorrectPerm(A0,S0,A,S)      try:        Diff = abs(np.dot(np.linalg.inv(np.dot(A0.T,A0)),np.dot(A0.T,gA)))    except np.linalg.LinAlgError:        Diff = abs(np.dot(np.linalg.pinv(A0),gA))        print('ATTENTION, PSEUDO-INVERSE POUR LE CRITERE SUR A')      z = np.shape(gA)    if optMedian==1:        p = np.median(Diff - np.diag(np.diag(Diff)))    else:        p = (np.sum(Diff - np.diag(np.diag(Diff))))/(z[1]*(z[1]-1))        return p# Generates a mixing matrix simulating elution typesdef generateAGauss(m,n,standDev,mBarre,nUnderMBarre):    A = np.zeros((m,n))        indP1 = np.linspace(0,mBarre,num=nUnderMBarre,dtype=int);    print('mBarre: %s'%mBarre)    for ii in range(nUnderMBarre):        A[indP1[ii],ii] = 1        A[:,ii] = np.convolve(A[:,ii],sng.gaussian(len(A[:,ii]), standDev),mode='same')            indP2 = np.linspace(mBarre+1,m-1,num=n-nUnderMBarre,dtype=int);    for ii in range(nUnderMBarre,n):        A[indP2[ii-nUnderMBarre],ii] = 1        A[:,ii] = np.convolve(A[:,ii],sng.gaussian(len(A[:,ii]), standDev),mode='same')    return A    # Creates data simulating a 1H NMR experiment. The mixing matrix simulates elution types and the sources are realistic sources convolved with a Laplacian to simulate a given spatial resolution. def Make_Experiment_HMR(n_s=2,n_obs=2,t_samp=1024,noise_level=40,standDev = 3,peak_width=0.05,optNorm=1):    notIn = [34,39,40,41,42]    nUnderMBarre = np.ceil(n_s/2)    nUnderMBarre = nUnderMBarre.astype(int)    mBarre = np.floor(0.75*n_obs)        peakList = snp.returnPeakList()    S0 = np.zeros((len(peakList),t_samp))    compt = 0    for key in peakList:        (spectrum, ppm) = snp.get_nmr_spectrum(peakList[key],[0,10],num_samples=t_samp,peak_width=peak_width)        if optNorm == 1:            S0[compt,:] = spectrum/np.sum(spectrum)        else:            S0[compt,:] = spectrum                compt +=1    S0 = np.delete(S0,notIn,0)    ind = range(0,n_s)    S0 = S0[ind,:]        A0 = generateAGauss(n_obs,n_s,standDev,mBarre,nUnderMBarre)    X0 = np.dot(A0,S0)        N = np.random.randn(n_obs,t_samp)    sigma_noise = np.power(10,(-noise_level/20))*np.linalg.norm(X0,ord='fro')/np.linalg.norm(N,ord='fro')    N = sigma_noise*N    X = X0 + N    return X,X0,A0,S0,N